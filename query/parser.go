package query

/*

A query is basically a JSON packet that has a particular structure. For performance reasons,
BSON may be substituted for JSON. The top-level structure is an object with one of the following
keys:

//////////////////////////////////
// FETCHING
//////////////////////////////////

"parameters":

The 'parameters' keyword is a simple object which contains the name of parameters that
may be used as values in the filter section of the query. This is useful especially
when the 'table' parameter references a pre-compiled query. In that case, much of the
support machinery for the query can be omitted since the server already has it compiled
and stored.

This is also the mechanism by which a subquery correlates with a parent query. The value
in that case must be an object with two elements: 'table' and 'column':

	{
		"some_value"   : 5,
		"parent_value" : {"table" : "test_table", "column" : "col1"}
	}


"from":

This key indicates what source the data is taken from. The value must be an object with one or
more of the following keys:

	"table"
	"join"

	The 'table' key expects a single value of type string, which is the name of the table.
	For example:

	"table" : "test_table"

	The 'join' key expects an array of objects indicating what joins exist and how to join them.
	For example:

	"join" : [{"inner" : "some_table",
	           "on"    : {"left_column" : "col1", "right_column" : "col2", "condition" : "eq"}
	          },
	          {"inner" : "some_other_table",
	           "on"    : {"left_column" : "col1", "right_column" : "col4", "condition" : "eq"},
	          }]

	Would be equivalent to:

	FROM test_table
	INNER JOIN some_table ON test_table.col1 = some_table.col2
	INNER JOIN some_other_table ON test_table.col1 = some_other_table.col4

	The inner part of a join clause can also have a filter attached.

	"join" : [{"inner"  : "some_table",
	           "on"     : {"left_column" : "col1", "right_column" : "col2", "condition" : "eq"}
	           "filter" : ["col3", "<", 4]
	         }]

	Any columns in the filter clause bind naturally to the joined table. So this example would
	be equivalent to:

	FROM test_table
	INNER JOIN some_table ON test_table.col1 = some_table.col2 AND some_table.col3 < 4




"filter":

This key indicates the conditions that must be met by each row returned. If the value is an
array, then each expression will be considered as part of a larger 'and' clause. If the value
is an object, then the key must be one of:

	'and'
	'or'

	The value attached to these keys follows the same properties as the one attached to filter.
	The pattern is recursive, to whatever depth the system supports.

	For example:

	"filter" : [["col1", "=", 5], ["col2",'=', 10]]

	Would be equivalent to: WHERE col1=5 AND col2=10

	"filter" : { "or" : [["col1", "=", 5], ["col2",'=', 10]] }

	Would be equivalent to: WHERE col1=5 OR col2=10

	"filter" : { "or" : [{"and" : ["col1", "=", 5], ["col2",'=', 10]},
						 {"and" : ["col1", "=", 100], ["col2",'=', 1000]}]}

	Would be equivalent to: WHERE (col1=5 AND col2=10) OR (col1=100 AND col2=1000)


"select":

This key indicates what columns will be fetched from the data once one or more matching
rows have been located. This is an array which has, in it's simplest form, a list of
strings representing columns names. For example:

	"select" : ["col1", "col2"]

	Would be just like:

	SELECT col1, col2

	However, we can do more powerful selections, including transformations:

	"select" : [{"input" : "col1", "output" : "mycol"}, "col2"]

	Which simply renames the input column name to the output column name much
	like:

	SELECT col1 AS mycol, col2

	If you need to specify a table name:

	"select" : [{"input_table" : "other_table", "input_column" : "col1", "output" : "mycol"}, "col2"]

	You may also indicate that a particular column is produced by a subquery:

	"select" : [{"subquery" : { ... }, "output" : "mycol"}]

	The 'subquery' indicates that the results should be fetched by first evaluating the
	subquery. The value of the subquery is an object which has the same structure as the
	top-level object. It simply allows recursion.

	A correlated query can be generated by using the 'parameters' section as described above.
	For example:

	"from"   : { "table" : "test_table"}
	"select" : [{"subquery" : {
					"parameters" : {
						"some_value" : {"table" : "test_table", "column" : "col1"}
					},
					"from" : {
						"table" : "another_table"
					},
					"filter" : [
						["col2", '=', {"param" : "some_value"}]
					],
					"select" : ["col1"]
				},
				"output" : "mycol"}]

	That would be loosely the same as:

	SELECT (SELECT col1 FROM another_table WHERE col2 = test_table.col1) AS mycol
	FROM test_table

//////////////////////////////////
// SCHEMA DEFINITION
//////////////////////////////////

Adjusting schema involves sending one or more schema definition commands in an array. Each
entry in the array has an object with a command field.


For example, CREATE TABLE appears like this:
{"cmd": "create", item: "table", columns: [{name:"col1", type:"bigint", nullable: false}]}



*/
